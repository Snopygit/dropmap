<!DOCTYPE html>
 <html lang="de">
 <head>
   <meta charset="UTF-8" />
   <title>Busroute ziehen und Drop berechnen</title>
   <style>
     body { margin: 0; background: #111; color: white; font-family: sans-serif; overflow-x: hidden; }
     body { margin: 0; background: #111; color: white; font-family: sans-serif; overflow: hidden; }
     /* Header */
     .header { position: fixed; top: 0; left: 0; width: 100%; height: 50px; background: #111; display: flex; align-items: center; justify-content: space-between; padding: 0 20px; box-sizing: border-box; z-index: 1000; }
     .header a { display: flex; align-items: center; text-decoration: none; color: white; }
 @@ -30,6 +30,12 @@
     /* Controls */
     .controls { display: flex; justify-content: center; gap: 10px; margin-bottom: 40px; }
     .controls button { padding: 10px 20px; border-radius: 30px; background: #007bff; color: white; border: none; font-weight: bold; cursor: pointer; font-size: 14px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); }
 
     /* Unauthorized Popup */
     .unauth-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.7); z-index: 1002; }
     .unauth-popup { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; padding: 20px 30px; border-radius: 12px; box-shadow: 0 0 20px 5px #7289DA; color: white; z-index: 1003; text-align: center; }
     .unauth-popup p { margin: 0 0 20px; font-size: 18px; }
     .unauth-popup button { background: #dc3545; color: white; border: none; padding: 10px 20px; border-radius: 8px; font-size: 16px; cursor: pointer; font-weight: bold; }
   </style>
 </head>
 <body>
 @@ -56,9 +62,17 @@
     <button onclick="resetRoute()">ðŸ”„ Reset</button>
   </div>
 
   <!-- Unauthorized Popup -->
   <div class="unauth-overlay" id="unauthOverlay" style="display:none;"></div>
   <div class="unauth-popup" id="unauthPopup" style="display:none;">
     <p>Du bist nicht whitelisted!</p>
     <button onclick="logout()">Log mich aus</button>
   </div>
 
   <script>
     // --- Discord-User laden & Whitelist prÃ¼fen ---
     const WHITELIST = [
       '775406913206353980',
       '1221451449695735884',
       '644602114256928789',
       '868581285277347920'
 @@ -70,16 +84,13 @@
         return;
       }
       try {
         const res = await fetch('https://discord.com/api/users/@me', {
           headers: { 'Authorization': 'Bearer ' + token }
         });
         const res = await fetch('https://discord.com/api/users/@me', { headers: { 'Authorization': 'Bearer ' + token } });
         if (!res.ok) throw new Error();
         const user = await res.json();
         // Whitelist check
         if (!WHITELIST.includes(user.id)) {
           alert('Zugriff verweigert. Du bist nicht authorisiert.');
           localStorage.removeItem('discord_token');
           window.location.href = 'index.html';
           document.getElementById('unauthOverlay').style.display = 'block';
           document.getElementById('unauthPopup').style.display = 'block';
           return;
         }
         document.getElementById('userName').textContent = `${user.username}#${user.discriminator}`;
 @@ -98,8 +109,7 @@
     // --- Canvas & Map Logic ---
     const canvas = document.getElementById('mapCanvas');
     const ctx = canvas.getContext('2d');
     const img = new Image(); img.src = 'fortnite-dropmap/assets/map.png';
     img.onerror = () => alert('Fehler: Karte konnte nicht geladen werden.');
     const img = new Image(); img.src = 'fortnite-dropmap/assets/map.png'; img.onerror = () => alert('Fehler: Karte konnte nicht geladen werden.');
 
     const dropmaps = JSON.parse(localStorage.getItem('dropmaps') || '[]');
     const editingIndex = +localStorage.getItem('editingDropmapIndex');
 @@ -110,75 +120,16 @@
     img.onload = draw;
 
     canvas.addEventListener('wheel', e => {
       e.preventDefault();
       const delta = e.deltaY > 0 ? -0.1 : 0.1;
       e.preventDefault(); const delta = e.deltaY > 0 ? -0.1 : 0.1;
       const mx = (e.offsetX - ox)/scale, my = (e.offsetY - oy)/scale;
       scale = Math.min(Math.max(0.5, scale + delta), 3);
       ox = e.offsetX - mx * scale;
       oy = e.offsetY - my * scale;
       ox = e.offsetX - mx*scale; oy = e.offsetY - my*scale;
       draw();
     });
 
     canvas.addEventListener('mousedown', e => {
       dragStart = { x: e.clientX, y: e.clientY };
       dragging = 'map'; offX = e.clientX - ox; offY = e.clientY - oy;
       const rect = canvas.getBoundingClientRect();
       const x = (e.clientX - rect.left - ox)/scale;
       const y = (e.clientY - rect.top - oy)/scale;
       route.forEach((pt,i) => {
         if (Math.hypot(pt.x-x, pt.y-y) < 12) {
           dragging = i; offX = pt.x - x; offY = pt.y - y;
         }
       });
     });
 
     canvas.addEventListener('mousemove', e => {
       if (!dragStart) return;
       if (dragging === 'map') {
         ox = e.clientX - offX; oy = e.clientY - offY;
       } else {
         const rect = canvas.getBoundingClientRect();
         const x = (e.clientX - rect.left - ox)/scale;
         const y = (e.clientY - rect.top - oy)/scale;
         route[dragging] = { x: x + offX, y: y + offY };
       }
       draw();
     });
 
     canvas.addEventListener('mouseup', () => { dragStart = null; dragging = null; });
 
     function drawArrowLine(a,b) {
       const dx = b.x-a.x, dy = b.y-a.y;
       const len = Math.hypot(dx,dy), steps = Math.floor(len/30), ang = Math.atan2(dy,dx);
       for(let i=0;i<steps;i++){ const x=a.x+dx*(i/steps), y=a.y+dy*(i/steps);
         ctx.save(); ctx.translate(x,y); ctx.rotate(ang);
         ctx.beginPath(); ctx.moveTo(-5,-5); ctx.lineTo(5,0); ctx.lineTo(-5,5); ctx.closePath(); ctx.fillStyle='#fff'; ctx.fill(); ctx.restore();
       }
     }
 
     function draw() {
       canvas.width=900; canvas.height=900;
       ctx.setTransform(scale,0,0,scale,ox,oy);
       ctx.clearRect(0,0,900,900);
       ctx.drawImage(img,0,0,900,900);
       drawArrowLine(route[0],route[1]);
       route.forEach(p=>{
         ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(p.x,p.y,10,0,2*Math.PI); ctx.fill();
         ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke();
       });
       dropmap.points.forEach(p=>{
         ctx.fillStyle='yellow'; ctx.beginPath(); ctx.arc(p.x,p.y,6,0,2*Math.PI); ctx.fill();
         ctx.strokeStyle='black'; ctx.lineWidth=2; ctx.stroke();
       });
       if(bestLine) {
         const {best,drop}=bestLine;
         ctx.fillStyle='rgba(0,255,255,0.5)'; ctx.beginPath(); ctx.arc(best.x,best.y,8,0,2*Math.PI); ctx.fill();
         ctx.strokeStyle='cyan'; ctx.setLineDash([5,5]); ctx.beginPath(); ctx.moveTo(best.x,best.y); ctx.lineTo(drop.x,drop.y); ctx.stroke(); ctx.setLineDash([]);
       }
     }
 
     function resetRoute(){ route[0]={x:150,y:150}; route[1]={x:750,y:750}; bestLine=null; draw(); }
     function calculateDrops(){ if(!dropmap.points.length) return; const dx=route[1].x-route[0].x, dy=route[1].y-route[0].y; const len=Math.hypot(dx,dy), ux=dx/len, uy=dy/len; let bestDist=Infinity, best=null, dropPt=null; dropmap.points.forEach(p=>{ const px=p.x-route[0].x, py=p.y-route[0].y; const proj=px*ux+py*uy; const projPt={x:route[0].x+ux*proj,y:route[0].y+uy*proj}; const d=Math.hypot(projPt.x-p.x,projPt.y-p.y); if(d<bestDist){bestDist=d; best=projPt; dropPt=p;} }); bestLine={best,drop:dropPt}; draw(); }
   </script>
 </body>
 </html>
       const rect = canvas.getBoundingClientRect(); const x = (e.clientX-rect.left-ox)/scale;
       const y = (e.clientY-rect.top-oy)/scale;
       route.forEach((pt,i) => { if (Math.hypot(pt.x-x,pt.y---
